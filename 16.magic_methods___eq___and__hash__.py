# В Python есть специальная функция hash(), которая вычисляет hash по определённому алгоритму для НЕИЗМЕНЯЕМЫХ объектов
# (для одинаковых объектов, hash будет одинаковым)

print(hash(123))
print(hash(123))

print(hash("Python"))
print(hash("Python"))

hash((1, 2, 3))
hash((1, 2, 3))

# При это если хеши одинаковые, это не значит(крайне редко) что объекты одинаковые
# - Если объекты a == b (равны), то РАВЕН и хеш
# - Равные хеши: hash(a) == hash(b) НЕ ГАРАНТИРУЮТ равенство объектов
# - Если хеши не равны: hash(a) != hash(b), то объекты ТОЧНО НЕ РАВНЫ

# Некоторые объекты Python(например словари) используют хеши в качестве ключей
# (неизменяемые типы данных, как и аргументы функции hash())
d = {}
d[5] = 5
d["python"] = '123'
# Будет ошибка unhashable type: 'list' нехешируемый тип данных
# d[[1, 2, 3]] = 1

# Словарь хранит ключи следующим образом(хеш ключа, ключ)
# ПЕРВОНАЧАЛЬНО записи в словаре ИЩУТСЯ ПО ХЕШУ и если обнаруживаются ДУБЛИРУЮЩИЕ хеши,
# то поиск проходит по самому объекту ключа
# Такой подход значительно ускоряет поиск ключей в словаре


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __hash__(self):
        # Мы передаем функции hash() НЕ сам экземпляр класса(self), а его локальные свойства!
        # Теперь hash() будет работать с экземплярами класса
        # Тоесть, мы подменили вычисление хеша с объекта класса Point, на его локальные свойства
        return hash((self.x, self.y))

p1 = Point(1, 2)
p2 = Point(1, 2)

# Вычисляем хеши у экземпляров класса
# print('Хеши для p1 и p2 :', hash(p1), hash(p2), sep='\n')
# Наши экземпляры класса ВОСПРИНИМАЮТСЯ КАК НЕИЗМЕНЯЕМЫЕ, поэтому мы можем вычислять их хеш
# Хеши разные, как и при записи p1 == p2


# Попробуем переопределить(прописать) магический метод __eq__(), который и отвечает за оператор '==' и еще раз проверим
print(p1 == p2)


# ТЕПЕРЬ будет исключение, так как когда мы прописываем свой магический метод __eq__(),
# то функция hash() ПЕРЕСТАЕТ РАБОТАТЬ(перестает работать СТАНДАРТНЫЙ АЛГОРИТМ ВЫЧИСЛЕНИЯ ХЕША)
# print('Хеши для p1 и p2 :', hash(p1), hash(p2), sep='\n')

# Прописываем магический метод __hash__(), и теперь можем применять функцию hash() к нашим экземплярам класса Point
print('Хеши для p1 и p2 :', hash(p1), hash(p2), sep='\n')

# Теперь у двух экземпляров класса одинаковый хеш, что значит,
# что мы можем использовать экземпляры класса в качестве ключей в словаре
d = {}
d[p1] = 1
d[p2] = 2

# Мы видим, что у этого словаря все ОДИН ключ(в виде объекта класса Point), со значением 2, это говорит о том,
# что экземпляры класса p1 и p2 сейчас воспринимаются как ОДИН КЛЮЧ, так как их ХЕШИ равны и оператор == возвращает True
# Если мы закомментируем наши магические методы, то словарь будет иметь ДВА ключа
# Если мы поменяем локальные свойства экземпляров класса Point(p1, p2) на разные значения,
# то сможем в словаре будут ДВА РАЗНЫХ КЛЮЧА
print(d,  d[p1], d[p2], sep='\n')

# ПО ИТОГУ мы получили то, что экземпляры класса с одинаковыми локальными свойствами воспринимаются как одниковые объекты
