# В Python допускается множественное наследование
# (когда один ДОЧЕРНИЙ класс наследуется от НЕСКОЛЬКО РОДИТЕЛЬСКИЙ классов)

# Мы делаем интернет магазин по продаже электроники(каждый товар определяется своим классом)
# и у всех товаров будет один базовый класс

# Базовый класс
class Goods:
    def __init__(self, name, weight, price):
        # Вопрос, а откуда super() понял, что следует обратиться к MixinLog, а не к базовому классу object?
        # ответ внизу!
        super().__init__()
        print("Инициализатор Goods")
        self.name = name
        self.weight = weight
        self.price = price

    def print_info(self):
        print(f'{self.name}, {self.weight}, {self.price}')


# Миксин(независимый класс, который добавляет дополнительный функционал по логированию товара, используя их ID
class MixinLog:
    ID = 0

    def __init__(self):
        print('Инициализатор MixinLog')
        MixinLog.ID += 1
        self.id = MixinLog.ID

    # Метод логирования
    def save_sell_log(self):
        print(f'{self.id}: товар был продан 00:00 часов')

    def print_info(self):
        print(f'print_info из класса MixinLog')


# Дочерний класс для ноутбуков
# Порядок ЗАПИСИ родительских классов важен, так как сначала идет поиск первого класса
class NoteBook(Goods, MixinLog):
    # Если методы с одинаковыми именами существуют в нескольких родительских классах
    # и надо его вызывать из СТРОГО ОПРЕДЕЛЕННОГО
    def print_info(self):
        MixinLog.print_info(self)


n = NoteBook('Acer', 1.5, 3000)
n.print_info()

# Предположим, что нам сказали, что нужно добавить логирование
# Тут нам понадобиться использовать миксины
n.save_sell_log()

# ОТВЕТ, в Python есть специальный алгоритмы обхода базового класса при множественном наследовании
# MRO - Method Resolution Order
# По итогу сначала метод ищется в дочернем классе, потом в первом Родители(первым в скобках), потом во втором,
# когда закончатся родители, тогда в object
# Мы можем это проверить используя магический метод __mro__()
# Мы получим список классов которые обходятся при поиске атрибутов
# (именно по этому порядку будет работать функция super())
print(NoteBook.__mro__)

# Когда мы собираемся использовать множественное наследование, то структуру наследования надо продумывать так,
# сначала прописывается базовый класс, который имеет дополнительные параметры,
# а потом вспомогательные классы(чтобы инициализаторы вспомогательных классов имели только один параметр self)

# Если у нас будет два одинаковых метода в базовом классе, и в Mixin,
# то естественно будет выполнятся метод из базового класса, если нам нужно вызвать метод именно из Mixin,
# то мы можем прописать
MixinLog.print_info(n)
# Но если нам надо ПОСТОЯННО вызывать метод из Mixin, то лучше прописать это в дочернем классе
n.print_info()