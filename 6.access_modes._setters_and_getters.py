# Режим доступа основной механизм инкапусляции
# Класс следует понимать как единый и целый механизм,
# чтобы случайно не нарушить алгоритм поведения внутри этого класса,
# следует взаимодействовать с ним только через ПУБЛИЧНЫЕ(Public доступ) методы и свойства.

# attribute (без одного или двух подчеркиваний вначале) - публичное свойство (public)
# _atrtribute (с одним подчеркиванием) - режим доступа (protected) служит для обращения внутри класса и во всех его дочерних классах
# __attribute (с двумя подчеркиваниями) - режим доступа (private) служит для обращения ТОЛЬКО внутри класса

# Импорт двух декораторов для методов класса из модуля accessify
from accessify import private, protected

class Point:
    def __init__(self, x=0, y=0, z=0, p=0):
        # Публичный доступ
          self.z = z

        # Protected доступ
          self._x = x
          self._y = y

        # Private доступ
          if self.__check_value(p):
                self.__p = p
          else:
              self.__p = 0

    # Декоратор из модуля accessify, если мы уберем Private доступ и сделаем публичный доступ для __check_value
    # (два подчеркивания из всего кода, и обратимся напрямую из экземпляра класса к check_value,
    # то получим исключение
    @private
    @classmethod
    # Метод с доступом Private (метод класса, так как в дальнейшем можем обращаемся к атрибутам класса)
    def __check_value(cls, x):
        return type(x) in (int, float)

    # Метод для обновления и проверки введеных данных локального атрибута __p(с доступом Private)
    # Внутри класса мы можем обращаться к атрибутам с доступом Private(при этом из вне доступа уже нет)
    def set__p(self, p):
        if self.__check_value(p):
            self.__p = p
        else:
            raise ValueError("Координаты должны быть числами")

    # Метод для получения локального атрибута __p(с доступом Private)
    def get__p(self):
        return self.__p

    # Метод set__p называют Сеттером
    # Метод get__p называют Геттером
    # либо интерфейсными методами


# Создаем экземпляр класса Point
pt = Point(1, 2, 3, 4)


# Обращаемся к атрибутам(с доступом Public) экземпляра класса напрямую
# Успешно
print(pt.z)


# Обращаемся к атрибутам(с доступом Protected) экземпляра класса напрямую
# # Успешно, НО в чем отличия от публичного доступа?
# Protected доступ только СИГНАЛИЗИРУЕТ программисту, что данные свойства являются защищенными,
# но НИКАК не ограничивает доступ к ним из вне
print(pt._x, pt._y)

# Если мы не хотим, чтобы программист/пользователь класса Point
# напрямую имел доступ к локальным свойствам экземпляра класса Point,
# стоит их помечать закрытыми


# Обращаемся к атрибутам(с доступом Private) экземпляра класса напрямую
# Ошибка! Мы не можем напрямую обратиться через экземпляр класса к его локальным свойствам
try:
    print(pt.__p)
except AttributeError:
    print("Ошибка! 'Point' object has no attribute '__p'")


pt.set__p(3)
print(pt.get__p())

# Проверим, какие свойства есть у экземпляра класса pt
# Мы увидим _Point__p (это кодовые имена приватных свойств)
print(pt.__dict__)

# Значит, мы можем обратитьтся к нему на прямую, используя кодовое имя,
# ОДНАКО, так делать крайне не рекомендуется!!(работать со свойствами Private следует только через
# предусмотренные интерфейсные методы, иначе возможны непредвиденные ошибки)
print(pt._Point__p)

# Если у нас есть необходимость ЛУЧШЕ защитить МЕТОДЫ класса от доступа из вне, то мы можем использовать
# модуль accessify (командой в терминале pip install accessify). В этом модуле доступны два декоратора,
# # такая защита будет сильнее, чем два подчеркивания(мы уже не сможем обратиться напрямую, используя кодовое имя)
# В большенстве случаев, достаточно использовать __
