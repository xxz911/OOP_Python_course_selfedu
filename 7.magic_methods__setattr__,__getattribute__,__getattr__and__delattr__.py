# Класс представляется как пространство имен с 4 атрибутами(2 свойствами и 2 именами методов)
class Point:
    MAX_COORD = 100
    MIN_COORD = 0

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def set_coord(self, x, y):
        # Чтобы обратится к атрибутам класса внутри метода,
        # надо указать ссылку либо на экземпляр класса(Point.атрибут), это плохая практика, либо на сам класс
        if self.MIN_COORD <= x <= self.MAX_COORD:
            self.x = x
            self.y = y

    # Предположим, что нам нужен метод, который изменял бы свойство самого класса
    # При такой записи, мы получим НЕ ТО что хотели, мы создадим новое локальное свойство в экземпляре класса,
    # а свойство класса останется прежним!.
    # Дело в том, используя self и присваивая так значение мы не учли,
    # что присваивание(=) создает атрибут в локальном пространстве имен!
    def set_bount(self, left):
        self.MIN_COORD = left
    # Надо использовать декоратор метода класса и использовать ссылку на сам класс(cls)
    @classmethod
    def set_bount2(cls, left):
        cls.MIN_COORD = left


# Когда мы создаем экземпляры класса, то все атрибута класса остаются в САМОМ классе(не копируются в экземпляры класса),
# При этом атрибуты класса являются общими с экземплярами класса
# ( мы можем через экземпляры класса к ним(атрибутам класса) обращаться),
# Так как пространство имен экземпляров класса имеют ссылку на внешнее пространство имен
# (которым является пространство самого класса)
# (Если имени нет в пространстве имен экземпляра класса, то поиск продолжается во внешнем пространстве имен(в классе))
pt = Point(1, 2)
pt2 = Point(10, 20)

# Можем обратиться к внешнему пространству имен для экземпляра класса
print(pt.MIN_COORD)

# Проверяем метод set_bount(получили не что хотели (MIN_COORD!)
print(pt.set_bount(-100))
print(pt.__dict__)
print(Point.__dict__)
del pt.MIN_COORD

# Проверяем метод set_bount2(получили не что хотели!)
print(pt.set_bount2(-100))
print(pt.__dict__)
print(Point.__dict__)



print("НИЖЕ КОД ПРО МАГИЧЕСКИЕ МЕТОДЫ")
# Магические методы для атрибутов
# * item - это атрибут, к которому идет обращение. key - имя атрибута. value - значение, которое присваивается атрибуту
# __setattr__(self,key,value) - автоматически вызывается при изменении свойства key класса
# __getattribute__(self,item) - автоматически вызывается при получении свойства класса с именем item
# __getattr__(self,item) - автоматически вызывается при получении несуществующего свойства item класса
# __delattr__(self, item) - автоматически вызывается при удалении свойства item(неважно существует он или нет)
class Point2:
    MAX_COORD2 = 100
    MIN_COORD2 = 0

    def __init__(self, x, y):
        self.x = x
        self.y = y

    # Работает, когда идет ПРИСВОЕНИЕ значения какому-то атрибуту через экземпляр класса
    # Может пригодится, если мы хотим запретить создавать какой-либо к атрибут в экземпляр класса
    def __setattr__(self, key, value):
        # Проверяем когда работает метод
        print("Работает __setattr__ с атрибутом " + key)
        # Код для запрета создавния атрибута с именем 'z' в экземпляре класса
        if key == 'z':
            raise ValueError('Нельзя использовать имя z')
        else:
            # Обращаемся к базовому классу object и вызываем тот же метод с нашими параметрами для работы методы
            return object.__setattr__(self, key, value)


    # Работает, когда ОБРАЩАЕМСЯ к атрибуту через экземпляр класса
    # Может пригодится, если мы хотим запретить обращение к атрибуту через экземпляр класса
    def __getattribute__(self, item):
        # Проверяем когда работает метод
        print("Работает __getattribute__ c атрибутом " + item)
        # Код для запрета к доступу к атрибуту экземпляра класса
        if item == "x":
            raise ValueError('доступ запрещен')
        else:
            # Обращаемся к базовому классу object и вызываем тот же метод с нашими параметрами для работы методы
            return object.__getattribute__(self, item)


    # Работает, когда ОБРАЩАЕМСЯ к НЕСУЩЕСТВУЮЩИМУ атрибуту через экземпляр класса
    # Может пригодится, если мы хотим ОБРАТИТСЯ к НЕСУЩЕСТВУЮЩЕМУ атрибуту через экземпляр класса, то пусть
    # возвращается False, а не ошибка
    def __getattr__(self, item):
        # Проверяем когда работает метод
        print('Работает __getattr__ с атрибутом ' + item)
        # Код для возврата False, а не ошибки
        return False


    # Работает, когда УДАЛЯЕТСЯ атрибут из экземпляра класса
    def __delattr__(self, item):
        # Проверяем когда работает метод
        print('Работает __delattr__ с атрибутом ' + item)
        # Обращаемся к базовому классу object и вызываем тот же метод с нашими параметрами для работы методы
        return object.__delattr__(self, item)


# Работает магический метод(2 сообщения, т.к 2 атрибута) __setattr__
# при ПРИСВОЕНИИ значения какому-то атрибуту через экземпляр класса
pn = Point2(5, 15)
# Тут ошибка (работает как надо, создаем атрибут 'z')
try:
    pn.z = 5
except ValueError:
    print('Ошибка')
# Тут работает(наш текст из print)
pn.y = 9


# Работает магический метод __getattribute__ при ОБРАЩЕНИИ атрибута через экземпляр класса
# Тут ошибка (работает как надо, обращаемся к 'x')
try:
    a = pn.x
except ValueError:
    print('Ошибка')
# Тут работает(наш текст из print)
b = pn.y

# Работает магический метод __getattr__, когда ОБРАЩАЕМСЯ к НЕСУЩЕСТВУЮЩИМУ атрибуту через экземпляр класса
print(pn.c)

# Работает магический метод __delattr__, когда УДАЛЯЕТСЯ атрибут из экземпляра класса
del pn.x
