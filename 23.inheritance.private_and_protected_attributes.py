# attribute (без одного или двух подчеркиваний вначале) - публичное свойство (public)
# _atrtribute (с одним подчеркиванием) - режим доступа (protected) служит для обращения внутри класса
# и во всех его дочерних классах
# __attribute (с двумя подчеркиваниями) - режим доступа (private) служит для обращения ТОЛЬКО внутри класса

# Посмотрим, как режимы доступа работают при наследовании класса
# Базовый класс
class Geom:
    name = "Geom"

    def __init__(self, x1, y1, x2, y2):
        print(f"Инициализатор Geom вызван для :{self.__class__}")
        # Локальные свойства класса делаем приватными
        self.__x1 = x1
        self.__y1 = y1
        self.__x2 = x2
        self.__y2 = y2

    def get_coord(self):
        return (self.__x1, self.__y1)


# Наследуемся от Geom
class Rect(Geom):
    def __init__(self, x1, y1, x2, y2, full='red'):
        super().__init__(x1, y1, x2, y2)
        print("Инициализатор Rect")
        # Локальные свойства класса делаем приватными
        self.__full = full


r = Rect(0, 1, 10, 20)
# Мы видим, что координаты содержат имя РОДИТЕЛЬСКОГО класса,
# хотя при работе инициализатора в родительском классе self должна ссылаться на экземпляр класса ДОЧЕРНЕГО класса,
# а атрибут fill содержит уже префикс ДОЧЕРНЕГО класса.
# ПО ИТОГУ, работа приватных локальных свойств заключается в том, что ГДЕ ОНИ ПРОПИСАНЫ, тот префикс и будет стоять
print(r.__dict__)
# ИЗ ЧЕГО СЛЕДУЕТ, что мы не можем обратиться к локальным свойствам РОДИТЕЛЬСКОГО класса через экземпляр ДОЧЕРНЕГО класса
# print(r.get_coord()) получим исключение, если этот метод будет прописан в ДОЧЕРНЕМ классе
# Однако, если его прописать в РОДИТЕЛЬСКОМ КЛАССЕ, то все будет работать
print(r.get_coord())

# Приватные свойства жестко привязываются к тому классу, в котором они прописаны!

# Чтобы обращаться к приватным атрибутам из РОДИТЕЛЬСКОГО И ДОЧЕРНЕГО КЛАССА,
# надо использовать режим доступа (protected(с одним подчеркиванием))
# ПРИ ЭТОМ стоит помнить, что режим доступа protected НЕ ЗАПРЕЩАЕТ обращаться к атрибуту из вне,
# а просто сигнализирует разработчику о том, что это внутренний атрибут


class Geom2:
    __name2 = "Geom2"

    def __init__(self, x1, y1, x2, y2):
        print(f"Инициализатор Geom вызван для :{self.__class__}")
        # Локальные свойства класса делаем с режимом доступа protected
        self._x1 = x1
        self._y1 = y1
        self._x2 = x2
        self._y2 = y2
        # Создаем локальное свойство с доступом protected и присваиваем ему приватное свойство класса
        # (чтобы можно было обращаться из вне класса)
        self._name2 = self.__name2


class Rect2(Geom2):
    def __init__(self, x1, y1, x2, y2, full='red'):
        super().__init__(x1, y1, x2, y2)
        print("Инициализатор Rect")
        # Локальные свойства класса делаем приватными
        self._full = full

    def get_coord2(self):
        return (self._x1, self._y1)


r2 = Rect2(3, 4, 40, 60)
print(r2.__dict__)
print(r2.get_coord2())
# Такие же правила и для СВОЙСТВ и МЕТОДОВ самого класса,
# если в классе Geom2 мы сделаем свойство класса name приватным(__name),
# то мы НЕ СМОЖЕМ обратиться к нему на прямую из экземпляров класса
# print(r2.__name2) будет исключение
print(r2._name2)