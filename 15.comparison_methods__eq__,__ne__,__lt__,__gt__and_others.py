# Магические методы сравнений
# __eq__() - для равенства ==
# __ne__() - для неравенства !=
# __it__() - для оператора меньше <
# __le__() - для оператора меньше или равно <=
# __gt__() - для оператора больше >
# __ge__() - для оператора больше или равно >=

class Clock:
    # Переменная класса (число секунд в одном дне)
    __DAY = 86400

    # seconds: int подсказывает программисту, какой тип данных должен быть в переменной seconds,
    # но не ограничивает вводимый тип данных
    def __init__(self, seconds: int):
        if not isinstance(seconds, int):
            raise TypeError("Секунды должны быть целым числом")
        self.seconds = seconds % self.__DAY

    # Чтобы не было дублирования кода, создадим базовый метод проверки для магических методов
    @staticmethod
    def verify_data(other):
        if not isinstance(other, (int, Clock)):
            raise TypeError("Операнд справа должен иметь тип int или Clock")
        return other if isinstance(other, int) else other.seconds

    # Магический метод для операции '==' c экземплярами класса
    def __eq__(self, other):
        return self.seconds == self.verify_data(other)

    # Магический метод для операции '<' c экземплярами класса
    def __lt__(self, other):
        return self.seconds < self.verify_data(other)

    # Магический метод для операции '<=' c экземплярами класса
    def __le__(self, other):
        return self.seconds <= self.verify_data(other)

# Создаем два экземпляра класса
с1 = Clock(1000)
с2 = Clock(1000)


# Без прописанного магического метода __eq__(), проверяется id, поэтому будет False, а нам надо,
# чтобы проверялось локальное свойство seconds
# С нашим методом __eq__() ,будет True
print(с1 == с2)
print(с1 == 1100)

# С оператором != у нас все работает как надо, ХОТЯ мы его НЕ ПРОПИСЫВАЛИ!!
# ДЕЛО В ТОМ, что если есть прописанный __eq__(), то интерпретатор выполняет not(c1 == c2)
print(с1 != с2)
print(с1 != 1800)


# С оператором < у нас все работает как надо, так как мы прописали __lt__(), если не прописать его, то будет исключение
print(с1 < с2)
print(с1 < 200)

# Мы не прописывали метод для оператора ">", интерпретатор использовал наш прописанный магический метод __lt__()
# и вывел противоположный результат
print(900 > с2)
print(с1 > с2)


# Прописали метод для оператора ">=" __le__()
print(900 >= с2)
print(с1 >= с2)

# Не прописали магический метод для оператора "<=", но интерператор вывел противоположный результат от ">=" __le__()
print(с1 <= 200)
print(с1 <= с2)

