# __new__ - магический метод, который вызыввается перед созданием экземпляра класса
# __new__ - должен возвращать адресс созданного объекта
class Point:
    # cls ссылается на сам класс(Point)
    def __new__(cls, *args, **kwargs):
        print("вызов __new__ для " + str(cls))
        # обращаемся к базовому классу object(super)
        # и из него вызываем метод __new__(запускаем процесс создания экземпляра класса)
        # и возвращаем адрес нового созданного обьекта
        return super().__new__(cls)

    # self ссылается на экземпляр класса(pt)
    def __init__(self, x=0, y=0):
        print("вызов __init__ для " + str(self))
        self.x = x
        self.y = y

pt = Point(2,5)


# Упрощенный пример паттерна Singleton(можем создать только один экземпляр класса)
# В данном примере вторые и более экземпляры класса перезаписывают первый экземпляр(из-за работы __init__)
# в дальнейших уроках устраним этот недостаток и доработаем данный пример(щас главное понять, как работает __new__)
class DataBase:
    # в роле ссылки на экземпляр класса
    __instance = None

    def __new__(cls, *args, **kwargs):
        # Если __instance равен None(нет ни одного экземпляра класса),
        if cls.__instance is None:
            # __instance будет ссылать на единственный экземпляр класса
            cls.__instance = super().__new__(cls)
        # Если __instance содержит адрес(уже создан экземпляр класса),
        # то возвращаем адрес единственного экземпляра класса
        return cls.__instance

    # Если единственный экземпляр класса будет удалён, то __instance равен None и можно создать снова одни экземпляр класса DataBase
    def __del__(self):
        DataBase.__instance = None

    def __init__(self, user, psw, port):
        # Имя пользователя
        self.user = user
        # Пароль
        self.psw = psw
        # Порт
        self.port = port

    def connect(self):
        print(f"соединение с БД: {self.user}, {self.psw}, {self.port}")

    def close(self):
        print("закрытие соединения с БД")

    def read(self):
        return "данные из БД"

    def write(self, data):
        print(f"запись в БД {data}")

# Создаем два экземпляра класса DataBase
db = DataBase('root', '1234', 80)
db2 = DataBase('root2', '5678', 40)
# При попытке создания более одного экземпляра класса,
# все экземпляры класса после первого будут ссылаться на первый экземпляр(меняя его свойства)
print(db.user)
print(id(db), id(db2))
