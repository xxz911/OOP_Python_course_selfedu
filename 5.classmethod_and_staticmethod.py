# Методы класса!! обозначаются декоратором @classmethod
# (обращаются только к атрибутам класса(передаем ссылку на класс cls автоматически и через нее и обращаемся к атрибутам класса),
# но не могут обращаться к локальным атрибутам экземпляра класса)
# @classmethod используется в тех случаях, когда подразумевается, что метод будет работать с атрибутами класса,


# Статические методы!! обозначаются декоратором @staticmethod
# (эти методы НЕ имеют доступ не к атрибутам класса, не к атрибутам экземпляра класса)
# По сути независимая и самостоятельная функция класса
# @staticmethod используется в тех случаях, когда подразумевается, что метод будет работать только с параметрами,
# указанными внутри этой функции,


# Обычные методы!! вызываются из экземпляров класса(работают как с атрибутами класса, так и с атрибутами экземляров класса(через self)_


class Vector:
    # Атрибуты класса Vector
    MIN_COORD = 0
    MAX_COORD = 100

    @classmethod
    # Метод класса(работает исключительно с атрибутами класса), который проверяет значения в диапозоне
    def validate(cls, arg):
        return cls.MIN_COORD <= arg <= cls.MAX_COORD

    def __init__(self, x, y):
        # Используем метод класса для проверки корректности координат x и y при создании экземпляра класса
        self.x = self.y = 0

        # if Vector.validate(x) and Vector.validate(y): можем записать так, но это не универсально,
        # и считается плохой практикой использовать имя класса в методах лучше так
        if self.validate(x) and self.validate(y):
        # Так интерпетарор языка Python сам поймет из какого экземпляра класса был вызван метод класса
        # и сам подставит правльную ссылку на сам класс(cls) для validate(),
        # Эта запись более универсальная, так как при смене имени класса, не изменится правильная передача ссылки на сам класс,
        # и ничего в программе менять не надо
            self.x = x
            self.y = y

        # В качестве примера, можем использовать статический метод norm2() в __init__
        print(self.norm2(self.x, self.y))

    @staticmethod
    # Статический метод, по сути является сервисная(вспомогательная функция)
    # Высчитывает норму вектора
    def norm2(x, y):
        return x*x + y+y

    # Пример обычного методов класса
    def get_coord(self):
        return self.x, self.y

# Создаем экземпляр класса и используем обычные методы
v = Vector(1, 90)

res = v.get_coord()
res2 = Vector.get_coord(v)
print(res, res2)

# Используем метод класса(непосредственно через сам класс)
print(Vector.validate(80))

# Работа метода класса validate в __init__, так как проверка значений не прошла, были установлены значения по умолчанию
v2 = Vector(5, 300)
print(v2.__dict__)


# Разница между обычным методом и методом класса заключается в том,
# что вызывая обычный метод из самого класса (res2 = Vector.get_coord(v)),
# мы должны указать ссылку на экземпляр класса(self) из метода,
# а если метод объявлен как метод класса, то мы его вызываем из класса без каких-либо дополнительных ссылок,
# так как ссылка на сам класс передается автоматически(cls)


# Вызываем статический метод norm2()
# Статические методы могут вызываться как из класса, так и из его экземпляров,
# работаем только с теми параметрами, которые прописываем сами внутри функции(в примере x и y)
print(Vector.norm2(5, 6))
print(v.norm2(5, 6))


