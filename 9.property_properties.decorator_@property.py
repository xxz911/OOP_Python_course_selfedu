class Person:
    def __init__(self, name, old):
        self.__name = name
        self.__old = old

    # Геттер для old
    def get_old(self):
        return self.__old

    # Сеттер для old
    def set_old(self, old):
        self.__old = old

    # Создаем атрибут класса с именем приватной переменной, используем объект property(где в первом аргументе наш ГЕТЕР,
    # во втором Сеттер)
    # При считывании свойства, объект property автоматически вызывает на Геттер, а при записи данных, вызывает Сеттер
    # В итоге через переменную old мы можем как считывать так и менять приватный атрибут __old
    old = property(get_old, set_old)


# Создаем экземпляр класса
p = Person('Сергей', 20)
# Меняем локальное свойство old через Сеттер
p.set_old('35')
# Проверяем локальное свойство old
print(p.get_old())


# Однако, если приватных атрибутов много,
# то надо для каждого писать Геттеры и Сеттеры и помнить их названия, что НЕУДОБНО,
# Одним из решений, является использование объекта property

# Проверяем работу переменной с property.
# Получаем приватный атрибут
print(p.old)
# Меняем приватный атрибут
p.old = 8
print(p.old, p.__dict__)

# Тут может ВОЗНИКНУТЬ ВОПРОС, а почему в экземпляре класса p не создается локальное свойство 'old'?
# Дело в нашем свойстве класса, при использовании ОБЪЕКТА property, то в первую очередь выбирается он,
# ДАЖЕ если есть локальной свойство в экземпляре класса с таким же именем.

# Создаем локальное свойство в экземпляре класса с таким же именем, как и наша переменная property
p.__dict__['old'] = 0
p.old = 10
# (по итогу выполняется property!!)
print(p.old, p.__dict__)


# Теперь в нашем коде есть ФУНКЦИОНАЛЬНОЕ ДУБЛИРОВАНИЕ, дело в том,
# что мы можем обращатся к приватным атрибутам как через СЕТТЕР И ГЕТТЕР напрямую(используя методы set_old, get_old),
# так и через переменную propery
# У объекта poperty есть декораторы(setter, getter, deleter)
class Person2:
    def __init__(self, name2, old2):
        self.__name2 = name2
        self.__old2 = old2

    # Декоратор @property записывается ОБЯЗАТЕЛЬНО ПЕРЕД ГЕТТЕРОМ
    # (имена методов при использовании декоратора @propery должны СОВПАДАТЬ
    @property
    # Объект property для считывания приватного свойства __old2
    def old2(self):
        return self.__old2

    # Используем декоратор setter в объекте property
    @old2.setter
    # Объект property для изменения приватного свойства __old2
    def old2(self, old2):
        self.__old2 = old2

    # Используем декоратор deleter в объекте property
    @old2.deleter
    # Объект property при удалении приватного свойства __old2
    def old2(self):
        del self.__old2


# Создаем экземпляр класса Person2
p2 = Person2("Николай", 20)
# Используем объект property для считывания приватного свойства __ol2
print(p2.old2)
# Используем объект property для изменения приватного свойства __ol2
p2.old2 = 26
print(p2.__dict__)
# Используем объект property для удаления приватного свойства __ol2
del p2.old2
print(p2.__dict__)


# Теперь у нас нет ФУНКЦИОНАЛЬНОГО ДУБЛИРОВАНИЯ
# (нет геттеров и сеттером в классе, мы не можем обращаться к приватным атрибутам через них и через property,
# теперь ТОЛЬКО через property
# НА ПРАКТИКЕ при использовании объекта property для работы с приватными локальными СВОЙСТВАМИ,
# пользуются именно ДЕКОРАТОРАМИ property
