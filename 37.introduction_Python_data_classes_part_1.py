# Data Classes - классы данных

# Подключаем декоратор для классов данных и функцию field(для изменяемых типов данных при аннотации)
from dataclasses import dataclass, field
# Импортируем функцию pprint
from pprint import pprint


# Почти всегда нам надо прописывать в классе инициализатор
class Thing:
    def __init__(self, name, weight, price):
        self.name = name
        self.weight = weight
        self.price = price

    def __repr__(self):
        return f'Thing: {self.__dict__}'


# Если мы создадим экземпляр класса и выведем его в принт, то увидим малоинформативную информацию
# (мы не видим что за поля в экземпляре, чему они равны) а видим <__main__.Thing object at 0x7f8a46f9ccd0>
# Поэтому иногда прописывают магический метод __repr__ самостоятельно
t = Thing("Учебник по Python", 100, 1024)
print(t)
print()
# После версии Python 3.7, появилась возможность удобнее работать с классами данных, есть несколько инструментов
# 1. Использование декоратора


# Прописываем декоратор
@dataclass
# Создаем класс
class ThingData:
    # ОБЯЗАТЕЛЬНО нужно АННОТИРОВАТЬ ПАРАМЕТРЫ ИНИЦИАЛИЗАТОРА
    # ВАЖНО, в каком порядке мы записываем параметры, в том и порядке и идет набор параметров в инициализаторе
    name: str
    weight: int
    # Можем создавать свойства с начальным значением
    # (тогда при создании экземпляра если не ввести 3-ий аргумент, то будет 0.2)
    # ВАЖНО ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ ДОЛЖНЫ БЫТЬ ПОСЛЕДНИМИ!
    price: float = 0.2
    # ВАЖНО НЕЛЬЗЯ УКАЗЫВАТЬ ПО УМОЛЧАНИЮ ИЗМЕНЯЕМЫЕ ТИПЫ ДАННЫХ
    # Если нам надо создать пустой изменяемый объект, то используется функция field()(вызывается ВНУТРИ инициализатора!)
    dims: list = field(default_factory=list)

# Можем переопределить __init__(), __repr__(), __eq__()

    # Переопределили магический метод, для сравнения экземпляров класса по локальному атрибуту weight
    def __eq__(self, other):
        return self.weight == other.weight


# price будет по умолчанию 0.2
t2 = ThingData("Учебник по Python2", 200)
# По итогу у нас автоматически создается инициализатор и магический метод __repr__
print(t2)

# Мы видим, что у нас создались еще магические методы,
# например __eq__
# (сравнение на равенство экземпляров классов по атрибутам(кортежи атрибутов), по умолчанию работает иначе)
# Если нас не устраивает поведение __eq__, мы можем его переопределить, например чтобы сравнивался только weight
pprint(ThingData.__dict__)

# Проверим __eq__(сравнивается только вес) если бы не переопределяли, то по всем атрибутам сравнение
t2_2 = ThingData("Учебник по ООП2", 30, 24)
t2_3 = ThingData("Учебник по ООП", 30, 324)
print(t2_2 == t2_3, t2_3 == t2)
